<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This is a simple implementation of the work done by Ubique using ZKattest to prove that an ECDSA signature can be verified using a commitment on a public key stored in a BBS credential."><title>ecdsa_proof - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-916cea96.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ecdsa_proof" data-themes="" data-resource-suffix="" data-rustdoc-version="1.87.0 (17067e9ac 2025-05-09)" data-channel="1.87.0" data-search-js="search-e7298875.js" data-settings-js="settings-d72f25bb.js" ><script src="../static.files/storage-82c7156e.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-fb8c74a8.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../ecdsa_proof/index.html">ecdsa_<wbr>proof</a><span class="version">0.1.0</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>ecdsa_proof</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/ecdsa_proof/lib.rs.html#1-1444">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This is a simple implementation of the work done by Ubique using
ZKattest to prove that an ECDSA signature can be verified using a commitment
on a public key stored in a BBS credential.</p>
<p>The test at the end shows how to set up a system and check that the verification
is correct.
For a longer explanation, see our <a href="https://github.com/c4dt/how-2025-06-eID">Github Repo</a>
with Jupyter notebooks and more information.</p>
<p>WARNING: This is a work of a couple of days for a hands-on workshop.
While the general gist of how keys are generated, signatures created and verified,
ZKP written and verified is correct, I’m sure that there are:</p>
<ul>
<li>errors in this re-arrangement of @Lovesh’s excellent work from
<a href="https://github.com/docknetwork/crypto/blob/main/equality_across_groups/src/pok_ecdsa_pubkey.rs#L462">docknetwork/crypt</a></li>
<li>not optimal and not secure ways of treating private keys and other random secrets</li>
<li>commitment - BBS proof: nonce and context are static - it could directly integrate the
revealed values in the proof.</li>
</ul>
<p>So while this work has been done to the best of my knowledge, I definietly took a lot
of shortcuts and definitely valued simplicity for a hands-on-workshop over cryptographic
correctness.</p>
<p>May <a href="https://politics.media.mit.edu/papers/Rogoway_Moral_Cryptography.pdf">Rogaway, Chaum and Goldwasser</a>
have mercy on me :)</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="ecdsa/index.html" title="mod ecdsa_proof::ecdsa">ecdsa</a></dt></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.BBSPresentation.html" title="struct ecdsa_proof::BBSPresentation">BBSPresentation</a></dt><dd>A <a href="struct.BBSPresentation.html" title="struct ecdsa_proof::BBSPresentation">BBSPresentation</a> is a proof of knowledge of the <a href="struct.VerifiedCredential.html" title="struct ecdsa_proof::VerifiedCredential">VerifiedCredential</a>. It contains
a proof that the presentation has been signed by the <a href="struct.Issuer.html" title="struct ecdsa_proof::Issuer">Issuer</a>, and can be
verified by the certificate of the <a href="struct.Issuer.html" title="struct ecdsa_proof::Issuer">Issuer</a>.</dd><dt><a class="struct" href="struct.ECDSAProof.html" title="struct ecdsa_proof::ECDSAProof">ECDSA<wbr>Proof</a></dt><dd>An <a href="struct.ECDSAProof.html" title="struct ecdsa_proof::ECDSAProof">ECDSAProof</a> links the ECDSA signature from the <a href="struct.SecureElement.html" title="struct ecdsa_proof::SecureElement">SecureElement</a> to the <a href="struct.BBSPresentation.html#method.close" title="method ecdsa_proof::BBSPresentation::close">BBSPresentation::close</a>
messages in zero-knowledge.
The commitments are randomized representations of the holder’s public key.
The proofs link these commitments to the message to be signed, and between each other.</dd><dt><a class="struct" href="struct.Issuer.html" title="struct ecdsa_proof::Issuer">Issuer</a></dt><dd>The <a href="struct.Issuer.html" title="struct ecdsa_proof::Issuer">Issuer</a> represents here the government issuer in Swiyu, which can create new
credentials for the Holder (<a href="struct.MobilePhone.html" title="struct ecdsa_proof::MobilePhone">MobilePhone</a>s).
Each new credential is bound to the public key sent by the holder.
An <a href="struct.Issuer.html" title="struct ecdsa_proof::Issuer">Issuer</a> has a private key to sign credentials for the holders.
The certificate of the issuer, the public key, can be used by the <a href="struct.Verifier.html" title="struct ecdsa_proof::Verifier">Verifier</a> to
check that a certificate has been created by the <a href="struct.Issuer.html" title="struct ecdsa_proof::Issuer">Issuer</a></dd><dt><a class="struct" href="struct.MobilePhone.html" title="struct ecdsa_proof::MobilePhone">Mobile<wbr>Phone</a></dt><dd>The <a href="struct.MobilePhone.html" title="struct ecdsa_proof::MobilePhone">MobilePhone</a> represents a holder. It has:</dd><dt><a class="struct" href="struct.PublicSetup.html" title="struct ecdsa_proof::PublicSetup">Public<wbr>Setup</a></dt><dd>Globally known public values.
These values can be created by anyone and are needed by all actors.</dd><dt><a class="struct" href="struct.SEKeypair.html" title="struct ecdsa_proof::SEKeypair">SEKeypair</a></dt><dd>A <a href="struct.SecureElement.html" title="struct ecdsa_proof::SecureElement">SecureElement</a> keypair, with the private key stored in the
<a href="struct.SecureElement.html" title="struct ecdsa_proof::SecureElement">SecureElement</a> only, and only accessible via its id.</dd><dt><a class="struct" href="struct.SecureElement.html" title="struct ecdsa_proof::SecureElement">Secure<wbr>Element</a></dt><dd>The <a href="struct.SecureElement.html" title="struct ecdsa_proof::SecureElement">SecureElement</a> is a specially hardened part of the <a href="struct.MobilePhone.html" title="struct ecdsa_proof::MobilePhone">MobilePhone</a> which can create
keypairs. However, the private key is inaccessible to the applications. An application
can only request a signature from one of the private keys, but not access it directly.
While this makes it much more secure, it makes it also much more difficult to create
useful cryptographic algorithms.</dd><dt><a class="struct" href="struct.Swiyu.html" title="struct ecdsa_proof::Swiyu">Swiyu</a></dt><dd>A simple representation of the <a href="struct.Swiyu.html" title="struct ecdsa_proof::Swiyu">Swiyu</a> app. It needs to be set up correctly by the
user, which of course usually is done automatically.
But for our example we want to see how the public key gets transferred from the
<a href="struct.SecureElement.html" title="struct ecdsa_proof::SecureElement">SecureElement</a> to the <a href="struct.Swiyu.html" title="struct ecdsa_proof::Swiyu">Swiyu</a> app.
In the same way you’ll have to add the <a href="struct.VerifiedCredential.html" title="struct ecdsa_proof::VerifiedCredential">VerifiedCredential</a> manually.</dd><dt><a class="struct" href="struct.VerifiedCredential.html" title="struct ecdsa_proof::VerifiedCredential">Verified<wbr>Credential</a></dt><dd>A <a href="struct.VerifiedCredential.html" title="struct ecdsa_proof::VerifiedCredential">VerifiedCredential</a> is created by the <a href="struct.Issuer.html" title="struct ecdsa_proof::Issuer">Issuer</a> and holds the public key of the
<a href="struct.MobilePhone.html" title="struct ecdsa_proof::MobilePhone">MobilePhone</a> in a secure way.
We suppose that the first two positions are the x and y value of the holder’s
public key.</dd><dt><a class="struct" href="struct.Verifier.html" title="struct ecdsa_proof::Verifier">Verifier</a></dt><dd>A <a href="struct.Verifier.html" title="struct ecdsa_proof::Verifier">Verifier</a> in this demo only has to create random messages, and then verify that the
<a href="struct.ECDSAProof.html" title="struct ecdsa_proof::ECDSAProof">ECDSAProof</a> is correct.</dd><dt><a class="struct" href="struct.VerifierMessage.html" title="struct ecdsa_proof::VerifierMessage">Verifier<wbr>Message</a></dt><dd>The <a href="struct.VerifierMessage.html" title="struct ecdsa_proof::VerifierMessage">VerifierMessage</a> is used both for the signature from the
<a href="struct.SecureElement.html" title="struct ecdsa_proof::SecureElement">SecureElement</a> and in the <a href="struct.BBSPresentation.html" title="struct ecdsa_proof::BBSPresentation">BBSPresentation</a>.
This is a very simple implementation allowing to create scalars
for SecP256 and Bls12-381.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.PublicCommitment.html" title="enum ecdsa_proof::PublicCommitment">Public<wbr>Commitment</a></dt><dd>Use an enum to show that the commitments can be open, including the random value,
or closed, which is secure.</dd></dl></section></div></main></body></html>